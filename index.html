
<style>

/* Global Dark Mode */
body {
    background: #0d1117 !important;
    color: #e6edf3 !important;
    font-family: "Poppins", sans-serif;
    padding: 30px 20px;
    line-height: 1.6;
}

/* Section Card Wrapper
.section-card {
    background: #161b22;
    max-width: 900px;
    margin: 25px auto;
    padding: 25px;
    border-radius: 12px;
    border-left: 6px solid #ff6b81;
    box-shadow: 0 0 18px rgba(255,107,129,0.15);
} */

.section-card {
    background: #161b22;
    width: 90%;                 /* take 90% of page width */
    margin: 40px 0 100px 40px;   /* space from left + top + bottom */
    padding: 25px;              /* inner spacing */
    border-radius: 12px;
    border-left: 6px solid #ff6b81;
    box-shadow: 0 0 18px rgba(255,107,129,0.15);
}




/* Headings */
.section-card h2, 
.step-title, 
h3 {
    text-align: left !important;
    font-weight: 700;
    color: #ff6b81 !important;
    margin-bottom: 12px;
    padding-left: 5px;
}

/* Paragraphs */
.section-card p,
.step-text,
.section-card ul li {
    text-align: left !important;
    color: #e6edf3;
    font-size: 16px;
    margin-bottom: 12px;
}

/* Lists */
ul {
    margin-left: 0;
    padding-left: 20px;
}
ul li {
    margin-bottom: 6px;
}

/* All Images Centered */
img {
    display: block !important;
    margin: 20px auto !important;
    max-width: 70% !important;
    height: auto !important;
    border-radius: 14px;
    box-shadow: 0 0 20px rgba(255,107,129,0.25);
}

/* Code Block */
.code-box {
    background: #111;
    border: 1px solid #ff6b81;
    padding: 15px;
    border-radius: 10px;
    max-width: 900px;
    margin: 25px auto;
    box-shadow: 0 0 15px rgba(255,107,129,0.25);
}
.copy-btn {
    background: #ff6b81;
    border: none;
    padding: 6px 12px;
    border-radius: 6px;
    float: right;
    margin-bottom: 10px;
}

/* Uniform Image Glow Wrapper */
.soft-glow-img {
    max-width: 600px;
    margin: 30px auto;
    text-align: center;
}
.soft-glow-img img {
    width: 100%;
    border-radius: 16px;
    box-shadow: 0 0 25px rgba(255,107,129,0.25);
}
</style>












<!-- ===================== PROJECT 1 ‚Äî NEUROGRIP (FULL BOXED) ===================== -->

<div class="section-card">

    <h2>Project 1: NeuroGrip ‚úã ‚Üí Controlling Servo Motor Using EMG</h2>

    <p>
        Build a simple EMG-based system using the <b>Muscle BioAmp Shield</b>  
        and <b>Arduino Uno</b> to control a servo claw ‚Äî just like prosthetic hands!
    </p>

    <h3>üî¨ What is Electromyography (EMG)?</h3>
    <p>
        EMG measures electrical signals produced by muscle contractions.  
        These signals help detect muscle activation and control assistive tech.
    </p>

    <img src="https://raw.githubusercontent.com/upsidedownlabs/Muscle-BioAmp-BisCute/main/software/EMGEnvelop/EMGEnvelop.png">

    <h3>üß© About Muscle BioAmp Shield</h3>
    <p>
        An Arduino-compatible EMG shield with plug-and-play sensors,  
        accelerometers, OLEDs, and servo support.
    </p>

    <img src="https://store.upsidedownlabs.tech/wp-content/uploads/2023/01/Muscle-BioAmp-Shield-v0.3.jpg">

    <h3>üß∞ Supplies Needed</h3>
    <ul>
        <li>Muscle BioAmp Shield Kit</li>
        <li>Arduino Uno + USB Cable</li>
        <li>Servo Claw</li>
        <li>NuPrep Gel</li>
        <li>Wet Wipes</li>
        <li>Electrode Gel</li>
        <li>Arduino IDE</li>
    </ul>
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="arduniofirst.jpg" alt="">
</div>
    <hr>

    <h3>üß™ Step 2: Stacking on Arduino Uno</h3>
    <p>Align shield pins properly before pressing it in.</p>
    <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="stacking.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>

<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="stacking.png" alt="">
</div>

    <h3>üß¥ Step 3: Skin Preparation</h3>
    <p>Apply NuPrep gel ‚Üí rub gently ‚Üí wipe clean.</p>
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="skin prep.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>
    <h3>üîå Step 4: Connecting Electrode Cable</h3>
    <p>Connect the BioAmp cable exactly as shown ‚Äî do NOT put electrodes yet.</p>
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="connecting electrode.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>
    <h3>üìç Step 5: Electrode Placement</h3>
    <p>Place electrodes on forearm as shown below:</p>  
    <p><b>Using  EMG BioAmp Band</b></p>
    <ul>
        <li>IN+/IN‚àí positioned on ulnar nerve</li>
        <li>REF on opposite side</li>
        <li>Add small drops of electrode gel</li>
    </ul>
    <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="electrode placements.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>

    <h3>ü¶æ Step 6: Connect Servo Claw</h3>
    <p>
        Plug the servo claw into the BioAmp Shield ports.  
        Servo moves automatically based on muscle activation.
    </p>
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="connecting servo claw.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>
    <h3>üß† Step 7 ‚Äî Upload the EMG ‚Üí Servo Control Code</h3>
    <p>Paste the following code into Arduino IDE and upload:</p>

    <div class="code-box">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>
#if defined(ESP32) 
  // For ESP32 Servo library
  #include &lt;ESP32Servo.h&gt;
#else
  // Arduino Servo library
  #include &lt;Servo.h&gt;
#endif

// Samples per second
#define SAMPLE_RATE 500

// Make sure to set the same baud rate on your Serial Monitor/Plotter
#define BAUD_RATE 115200

// Change if not using A0 analog pin
#define INPUT_PIN A0

// envelopeee buffer size
// High value -> smooth but less responsive
// Low value -> not smooth but responsive
#define BUFFER_SIZE 64

// Servo pin (Change as per your connection)
#define SERVO_PIN 2 // Pin2 for Muscle BioAmp Shield v0.3

// EMG Threshold value, different for each user
// Check by plotting EMG envelopee data on Serial plotter
#define EMG_THRESHOLD 47

// Servo open & close angles
#define SERVO_OPEN 10
#define SERVO_CLOSE 90

// EMG Envelope baseline value
// Minimum value without flexing hand
#define EMG_ENVELOPE_BASELINE 4

// EMG Envelope divider
// Minimum value increase required to turn on a single LED
#define EMG_ENVELOPE_DIVIDER 4


Servo servo;
// Servo toggle flag
bool flag = 0;
// Last gesture timestamp
unsigned long lastGestureTime = 0;
// Delay between two actions
unsigned long gestureDelay = 240;

int circular_buffer[BUFFER_SIZE];
int data_index, sum;

// Muscle BioAmp Shield v0.3 LED pin numbers in-order
int led_bar[] = {8, 9, 10, 11, 12, 13};
int total_leds = sizeof(led_bar) / sizeof(led_bar[0]);

void setup() {
  // Serial connection begin
  Serial.begin(BAUD_RATE);
  // Initialize all the led_bar
    for (int i = 0; i < total_leds; i++) {
      pinMode(led_bar[i], OUTPUT);
    }
   servo.attach(SERVO_PIN);
   servo.write(0);
}

void loop() {
  // Calculate elapsed time
  static unsigned long past = 0;
  unsigned long present = micros();
  unsigned long interval = present - past;
  past = present;

  // Run timer
  static long timer = 0;
  timer -= interval;

  // Sample and get envelope
  if(timer < 0) {
    timer += 1000000 / SAMPLE_RATE;
   
    // RAW EMG Values
    int sensor_value = analogRead(INPUT_PIN);
    
    // Filtered EMG
    int signal = EMGFilter(sensor_value);
    
    // EMG envelopee
    int envelope = getEnvelope(abs(signal));

    // Update LED bar graph
    for(int i = 0; i<=total_leds; i++){
      if(i>(envelope/EMG_ENVELOPE_DIVIDER - EMG_ENVELOPE_BASELINE)){
          digitalWrite(led_bar[i], LOW);
      } else {
          digitalWrite(led_bar[i], HIGH);
      }
    }
     
    if(envelope > EMG_THRESHOLD) {
      if((millis() - lastGestureTime) > gestureDelay){
      if(flag == 1){
        servo.write(SERVO_OPEN);
        flag = 0;
        lastGestureTime = millis();
      }
      else {
        servo.write(SERVO_CLOSE);
        flag = 1;
        lastGestureTime = millis();
      }
      }
    } 
    
    // EMG Raw signal
    Serial.print(signal);
    // Data seprator
    Serial.print(",");
    // EMG envelopeee
    Serial.println(envelope);

  }
}

// envelope detection algorithm
int getEnvelope(int abs_emg){
  sum -= circular_buffer[data_index];
  sum += abs_emg;
  circular_buffer[data_index] = abs_emg;
  data_index = (data_index + 1) % BUFFER_SIZE;
  return (sum/BUFFER_SIZE) * 2;
}
float EMGFilter(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - 0.05159732*z1 - 0.36347401*z2;
    output = 0.01856301*x + 0.03712602*z1 + 0.01856301*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -0.53945795*z1 - 0.39764934*z2;
    output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - 0.47319594*z1 - 0.70744137*z2;
    output = 1.00000000*x + 2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -1.00211112*z1 - 0.74520226*z2;
    output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

</code></pre>
    </div>

    <!-- Warning Notice -->
<div style="background:linear-gradient(135deg,#7f1d1d,#991b1b); border-left:8px solid #ef4444; padding:20px 26px; border-radius:12px; margin:1.5em 0; color:#fee2e2; box-shadow:0 4px 18px rgba(0,0,0,0.3);">
  <strong style="font-size:17px; display:block; margin-bottom:10px;">‚ö†Ô∏è Important Notice</strong>
  <p>Keep laptop unplugged and remove the charger .</p>
</div>


    <h3>ü¶æ Step 9 ‚Äî Control the Servo Claw</h3>
    <p>
        Flex your muscles ‚Üí envelope rises ‚Üí servo toggles.  
        Stronger flex = higher EMG = faster servo movement.
    </p>

    <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="finalworking.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>

</div>

<!-- ===================== STEP 7 ===================== -->

<!-- ===================== PROJECT 3 ‚Äî MINDSCOPE (FULL BOXED) ===================== -->

<div class="section-card">

    <h2>Project 2: MindScope üîÆ ‚Üí Detecting Emotions Using EEG </h2>

    <p>
        In this project, you will record EEG signals using the <b>BioAmp EXG Pill</b>  
        and an <b>arduino Dev Board</b>, extract brainwave bandpowers using FFT,  
        and classify emotional states like <b>Focused, Calm, Drowsy, Daydreaming, Hyper-aware</b>.  
        The output appears live in the <b>Serial Monitor</b>.
    </p>

    <h3>üß∞ Hardware Required</h3>
    <ul>
        <li>arduino Dev Board</li>
        <li>BioAmp EXG Pill</li>
        <li>BioAmp Cable v3</li>
        <li>3 √ó Gel Electrodes</li>
        <li>3 √ó Jumper Cables</li>
        <li>NuPrep Skin Preparation Gel</li>
        <li>Wet Wipe</li>
        <li>Brain BioAmp Band (optional)</li>
        <li>Electrode Gel (if using Brain BioAmp Band)</li>
    </ul>

    <h3>üíª Software Required</h3>
    <ul>
        <li>Arduino IDE</li>
    </ul>

    <h3>üîå Circuit Diagram</h3>
    <img src="1.jpg" alt="Circuit diagram showing EEG setup">
     <img src="2.jpg" alt="Circuit diagram showing EEG setup">
      <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="3.mp4" type="video/mp4">
       
    </video>

    <h3>üß™ Step 1: Upload the EEG Emotion Detection Program</h3>
<h3 style="color:#ff8fa3; text-align:left; margin-top:30px;">üìç Electrode Placement</h3>

<!-- ===== Image 1: Band Placement ===== -->
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="band.jpg" alt="">
    <ul style="text-align:left; color:#e6edf3; margin-top:12px; font-size:15px;">
        <li>Place the two EEG electrodes on the Brain BioAmp Band.</li>
        <li>IN+ on the left side, IN‚àí on the right side.</li>
        <li>Ensure metal points touch the skin firmly.</li>
    </ul>
</div>

<!-- ===== Image 2: Band on Forehead ===== -->
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="backofhead.jpg" alt="">
    <ul style="text-align:left; color:#e6edf3; margin-top:12px; font-size:15px;">
        <li>Place the band properly on the forehead.</li>
        <li>Keep the band tight enough for stable contact.</li>
        <li>Avoid hair covering the electrodes.</li>
    </ul>
</div>

<!-- ===== Image 3: REF Electrode ===== -->
<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="backofear.jpg" alt="">
    <ul style="text-align:left; color:#e6edf3; margin-top:12px; font-size:15px;">
        <li>Attach the REF electrode behind the earlobe.</li>
        <li>Place it on the hard bony area for stability.</li>
        <li>This improves noise reduction and signal clarity.</li>
    </ul>
</div>
    <h3>üß† Step 1 Code: EEG Emotion Detection</h3>
    <p>
        Create a new sketch in Arduino IDE and paste the following code:
    </p>

    <div class="code-box">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>
#include &lt;arduinoFFT.h&gt;

// ================= EEG + FFT Config =====================
#define SAMPLE_RATE 512
#define FFT_SIZE 256
#define BAUD_RATE 115200
#define INPUT_PIN A2
#define LED_PIN 2

// ================= Frequency Bands ======================
#define DELTA_LOW 0.5
#define DELTA_HIGH 4.0
#define THETA_LOW 4.0
#define THETA_HIGH 8.0
#define ALPHA_LOW 8.0
#define ALPHA_HIGH 13.0
#define BETA_LOW 13.0
#define BETA_HIGH 30.0
#define GAMMA_LOW 30.0
#define GAMMA_HIGH 45.0

// Less smoothing ‚Üí responds faster
#define SMOOTHING_FACTOR 0.35
const float EPSILON = 1e-6f;

// ================= Structs ==============================
typedef struct {
  float delta, theta, alpha, beta, gamma, total;
} BandpowerResults;

typedef struct {
  float delta = 0, theta = 0, alpha = 0, beta = 0, gamma = 0, total = 0;
} SmoothedBandpower;

SmoothedBandpower smoothedPowers;

// ================= FFT Buffers ==========================
double vReal[FFT_SIZE];
double vImag[FFT_SIZE];
ArduinoFFT&lt;double&gt; FFT(vReal, vImag, FFT_SIZE, SAMPLE_RATE);

// ================= Timing ================================
unsigned long lastEmotionTime = 0;
unsigned long sampling_period_us;

// ================= Functions =============================
void smoothBandpower(BandpowerResults *raw, SmoothedBandpower *s) {
  s-&gt;delta = SMOOTHING_FACTOR * raw-&gt;delta + (1 - SMOOTHING_FACTOR) * s-&gt;delta;
  s-&gt;theta = SMOOTHING_FACTOR * raw-&gt;theta + (1 - SMOOTHING_FACTOR) * s-&gt;theta;
  s-&gt;alpha = SMOOTHING_FACTOR * raw-&gt;alpha + (1 - SMOOTHING_FACTOR) * s-&gt;alpha;
  s-&gt;beta  = SMOOTHING_FACTOR * raw-&gt;beta  + (1 - SMOOTHING_FACTOR) * s-&gt;beta;
  s-&gt;gamma = SMOOTHING_FACTOR * raw-&gt;gamma + (1 - SMOOTHING_FACTOR) * s-&gt;gamma;
  s-&gt;total = SMOOTHING_FACTOR * raw-&gt;total + (1 - SMOOTHING_FACTOR) * s-&gt;total;
}

BandpowerResults calculateBandpower(double *powerSpectrum, double binWidth) {
  BandpowerResults results = {0};

  for (int i = 1; i &lt; FFT_SIZE / 2; i++) {
    float freq = i * binWidth;
    float power = powerSpectrum[i];
    results.total += power;

    if (freq &gt;= DELTA_LOW &amp;&amp; freq &lt; DELTA_HIGH) results.delta += power;
    else if (freq &gt;= THETA_LOW &amp;&amp; freq &lt; THETA_HIGH) results.theta += power;
    else if (freq &gt;= ALPHA_LOW &amp;&amp; freq &lt; ALPHA_HIGH) results.alpha += power;
    else if (freq &gt;= BETA_LOW  &amp;&amp; freq &lt; BETA_HIGH)  results.beta  += power;
    else if (freq &gt;= GAMMA_LOW &amp;&amp; freq &lt; GAMMA_HIGH) results.gamma += power;
  }
  return results;
}

// ================= Emotion Classification ==================
void printEmotion() {
  float d = (smoothedPowers.delta / (smoothedPowers.total + EPSILON)) * 100;
  float t = (smoothedPowers.theta / (smoothedPowers.total + EPSILON)) * 100;
  float a = (smoothedPowers.alpha / (smoothedPowers.total + EPSILON)) * 100;
  float b = (smoothedPowers.beta  / (smoothedPowers.total + EPSILON)) * 100;
  float g = (smoothedPowers.gamma / (smoothedPowers.total + EPSILON)) * 100;

  String emotion = "Neutral";

  if (smoothedPowers.total &lt; 0.001) {
    emotion = "No Signal";
  }
  else if (d &gt; 60 &amp;&amp; b &lt; 10 &amp;&amp; g &lt; 10) {
    emotion = "Drowsy";
  }
  else if (t &gt; a &amp;&amp; t &gt; b &amp;&amp; t &gt; 15) {
    emotion = "Daydreaming";
  }
  else if (b &gt; 25 &amp;&amp; b &gt; a) {
    emotion = "Focused";
  }
  else if (a &gt; 25 &amp;&amp; a &gt; b) {
    emotion = "Calm";
  }
  else if (g &gt; 15) {
    emotion = "Hyper-aware";
  }

  Serial.print("Emotion: "); Serial.println(emotion);
  Serial.print("Delta: "); Serial.print(d, 1);
  Serial.print(" | Theta: "); Serial.print(t, 1);
  Serial.print(" | Alpha: "); Serial.print(a, 1);
  Serial.print(" | Beta: ");  Serial.print(b, 1);
  Serial.print(" | Gamma: "); Serial.println(g, 1);
}

// ================= Setup ==================
void setup() {
  Serial.begin(115200);
  pinMode(INPUT_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);

  sampling_period_us = round(1000000 * (1.0 / SAMPLE_RATE));

  Serial.println("EEG Emotion Detection (Improved) Started...");
}

// ================= Loop ==================
void loop() {
  unsigned long microseconds;

  // Sampling
  for (int i = 0; i &lt; FFT_SIZE; i++) {
    microseconds = micros();
    vReal[i] = analogRead(INPUT_PIN);
    vImag[i] = 0;
    while (micros() - microseconds &lt; sampling_period_us);
  }

  // FFT Processing
  FFT.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.compute(FFT_FORWARD);
  FFT.complexToMagnitude();

  double binWidth = (1.0 * SAMPLE_RATE) / FFT_SIZE;

  BandpowerResults raw = calculateBandpower(vReal, binWidth);
  smoothBandpower(&raw, &smoothedPowers);

  double b_pct = (smoothedPowers.beta / (smoothedPowers.total + EPSILON)) * 100;
  digitalWrite(LED_PIN, (b_pct &gt; 20.0 ? HIGH : LOW));

  if (millis() - lastEmotionTime &gt; 5000) {
    printEmotion();
    lastEmotionTime = millis();
  }
}
</code></pre>
    </div>

    <h3>üìä Step 2: View Your Emotions Live</h3>

    <p>
        Open <b>Tools ‚Üí Serial Monitor</b> in Arduino IDE  
        and set the baud rate to <b>115200</b>.
    </p>

    <p>You will see outputs like:</p>

    <div style="
        background:#050505;
        color:#00ff99;
        padding:18px;
        border-radius:14px;
        font-family:monospace;
        font-size:14px;
        max-width:700px;
        margin:20px auto;
        border:1px solid #ff6b81;
        box-shadow:0 0 16px rgba(255,107,129,0.4);
    ">
Emotion: Calm<br>
Delta: 12.3 | Theta: 18.4 | Alpha: 32.1 | Beta: 10.5 | Gamma: 2.1<br><br>
Emotion: Focused<br>
Delta: 10.2 | Theta: 8.4 | Alpha: 14.1 | Beta: 29.5 | Gamma: 3.0
    </div>

</div>
<!-- ===================== PROJECT 2 ‚Äî BLINK-A-SAUR (FULL BOXED) ===================== -->

<div class="section-card">

    <h2>Project 3: Blink-a-saur ü¶ñ ‚Üí Control Dino Game Using EOG Signals</h2>

    <p>
        In this project, you will create a fun game controller that lets you 
        <b>play the Chrome Dino Game using your eye blinks</b>.  
        Using EOG (Electrooculography) signals from your eyes,  
        the system detects blinks and triggers a <b>keyboard SPACE press</b> ‚Äî making the Dino jump!
    </p>

    <h3>üëÅÔ∏è What is Electrooculography (EOG)?</h3>
    <p>
        Electrooculography measures the electrical potential produced by eye movement.  
        The cornea is positively charged, the retina is negatively charged ‚Äî creating the  
        <b>electrooculogram</b>. When you blink, this voltage changes, and we detect it using  
        the <b>BioAmp EXG Pill</b>.
    </p>

    <h3>üß∞ Supplies Needed</h3>
    <p><b>HARDWARE:</b></p>
    <ul>
        <li>DIY Neuroscience Kit Pro</li>
        <li>BioAmp Cable (100 cm)</li>
        <li>Gel Electrodes</li>
        <li>NuPrep Skin Preparation Gel</li>
        <li>Wet wipes</li>
    </ul>

    <p><b>SOFTWARE:</b></p>
    <ul>
        <li>Arduino IDE</li>
        <li>Visual Studio Code</li>
        <li>Python</li>
    </ul>

    <h3>üî¨ About DIY Neuroscience Kit Pro</h3>
    <p>
        A complete portable neuroscience lab for EEG, EMG, ECG and EOG recordings ‚Äî  
        designed for HCI and BCI projects.
    </p>

    <h3>üß™ Step 1: Stack Muscle BioAmp Shield on Arduino Uno</h3>
    <p>Carefully align the pins and stack the <b>Muscle BioAmp Shield</b> on top of Arduino Uno.</p>
 <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="stacking.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>

<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="stacking.png" alt="">
</div>

    <h3>üß™ Step 2: Connecting BioAmp EXG Pill</h3>
  
      <img src="1.jpg" alt="Circuit diagram showing EEG setup">
     <img src="2.jpg" alt="Circuit diagram showing EEG setup">
 

    <p>Connect the <b>BioAmp EXG Pill</b> to the <b>A2 port</b> using the STEMMA cable.</p>

    <h3>üîå Step 3: Connecting Electrode Cable</h3>
    <p>Plug the BioAmp Cable into the EXG Pill exactly as shown.</p>
     <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="3.mp4" type="video/mp4">
       
    </video>

    <h3>üß¥ Step 4: Skin Preparation</h3>
    <p>
        Apply <b>NuPrep Gel</b> ‚Üí rub gently ‚Üí clean with wet wipe.  
        This reduces skin impedance and improves EOG signal quality.
    </p>
 <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="skinprep2.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>

 </div>

    <p><b>About NuPrep:</b> Removes dry skin and improves conductivity.</p>

    <h3>üìç Step 5: Electrode Placements</h3>
    <img src="https://content.instructables.com/FM2/O1W6/LNRH8FXV/FM2O1W6LNRH8FXV.jpg" alt="Electrode placement">

    <ul>
        <li>IN+ ‚Üí Forehead</li>
        <li>IN‚àí ‚Üí Below the eye</li>
        <li>REF ‚Üí Behind the earlobe</li>
    </ul>

<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="1.jpg" alt="">
</div>


<div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <img src="2.jpg" alt="">
</div>

    <h3>üß† Step 6 Code: EOG Dino Game Controller</h3>

    <div class="code-box">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>


#include &lt;Arduino.h&gt;
#include &lt;Keyboard.h&gt;  // HID keyboard library for Arduino R4
#include &lt;math.h&gt;

// #define DEBUG  // Uncomment this line to enable debugging

// ----------------- USER CONFIGURATION -----------------
#define SAMPLE_RATE       512          // samples per second
#define BAUD_RATE         115200
#define INPUT_PIN         A2
#define LED_PIN           LED_BUILTIN

// Envelope Configuration for EOG detection
#define ENVELOPE_WINDOW_MS 100  // Smoothing window in milliseconds
#define ENVELOPE_WINDOW_SIZE ((ENVELOPE_WINDOW_MS * SAMPLE_RATE) / 1000)

// Blink Detection Thresholds - adjust these based on your setup
const int BlinkLowerThreshold = 30; 
const int BlinkUpperThreshold = 50;

// Circular buffer for timing-based sampling
#define BUFFER_SIZE 64
float eogCircBuffer[BUFFER_SIZE];
int writeIndex = 0;
int readIndex = 0;
int samplesAvailable = 0;

// Single Blink Detection Configuration
const unsigned long BLINK_DEBOUNCE_MS = 300;   // minimum time between blinks to prevent double-triggering
unsigned long lastBlinkTime = 0;               // time of most recent blink
float currentEOGEnvelope = 0;

// HID Command Cooldown to prevent rapid-fire commands
const unsigned long HID_COOLDOWN_MS = 250;  // 250ms between space commands (allows ~4 jumps per second)
unsigned long lastHIDCommandTime = 0;

// EOG Envelope Processing Variables
float eogEnvelopeBuffer[ENVELOPE_WINDOW_SIZE] = {0};
int eogEnvelopeIndex = 0;
float eogEnvelopeSum = 0;

// Game Statistics
unsigned long totalBlinks = 0;
unsigned long gameStartTime = 0;

// EOG Statistics for debug display
#define SEGMENT_SEC 1
#define SAMPLES_PER_SEGMENT (SAMPLE_RATE * SEGMENT_SEC)
float eogBuffer[SAMPLES_PER_SEGMENT] = {0};
uint16_t segmentIndex = 0;
unsigned long lastSegmentTimeMs = 0;
float eogAvg = 0, eogMin = 0, eogMax = 0;
bool segmentStatsReady = false;

// --- Filter Functions ---

// Band-Stop Butterworth IIR digital filter, generated using filter_gen.py.
// Sampling rate: 512.0 Hz, frequency: [48.0, 52.0] Hz.
// Filter is order 2, implemented as second-order sections (biquads).
// Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
float Notch(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - -1.58696045*z1 - 0.96505858*z2;
    output = 0.96588529*x + -1.57986211*z1 + 0.96588529*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -1.62761184*z1 - 0.96671306*z2;
    output = 1.00000000*x + -1.63566226*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

// High-Pass Butterworth IIR digital filter, generated using filter_gen.py.
// Sampling rate: 512.0 Hz, frequency: 5.0 Hz.
// Filter is order 2, implemented as second-order sections (biquads).
// Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
float EOGFilter(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - -1.91327599*z1 - 0.91688335*z2;
    output = 0.95753983*x + -1.91507967*z1 + 0.95753983*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

float updateEOGEnvelope(float sample) 
{
  float absSample = fabs(sample); 

  // Update circular buffer and running sum
  eogEnvelopeSum -= eogEnvelopeBuffer[eogEnvelopeIndex];
  eogEnvelopeSum += absSample;
  eogEnvelopeBuffer[eogEnvelopeIndex] = absSample;
  eogEnvelopeIndex = (eogEnvelopeIndex + 1) % ENVELOPE_WINDOW_SIZE;

  return eogEnvelopeSum / ENVELOPE_WINDOW_SIZE;  // Return moving average
}

// HID Keyboard Functions
void sendSpaceBar() {
  unsigned long nowMs = millis();
  if ((nowMs - lastHIDCommandTime) >= HID_COOLDOWN_MS) {
    Keyboard.press(' ');  // Press space bar
    delay(30);            // Hold key for 30ms (shorter for gaming responsiveness)
    Keyboard.release(' ');
    lastHIDCommandTime = nowMs;
    totalBlinks++;
    
    Serial.print("JUMP! Blink #");
    Serial.println(totalBlinks);
    
    // LED feedback - quick single flash
    digitalWrite(LED_PIN, HIGH);
    delay(50);
    digitalWrite(LED_PIN, LOW);
  }
}

void setup() {
  Serial.begin(BAUD_RATE);
  delay(100);
  
  pinMode(INPUT_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  
  // Initialize HID Keyboard
  Keyboard.begin();
  
  // LED startup sequence - game ready indicator
  for(int i = 0; i &lt; 3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(200);
    digitalWrite(LED_PIN, LOW);
    delay(200);
  }
  
  gameStartTime = millis();
  lastSegmentTimeMs = millis();  // Initialize the segment timer
  
  Serial.println("=================================");
  Serial.println("Arduino R4 EOG Dino Game Controller");
  Serial.println("=================================");
  Serial.println("Single Blink = Space Bar (Jump)");
  Serial.println("Perfect for Chrome Dino Game!");
  Serial.println("");
  Serial.println("Instructions:");
  Serial.println("1. Open Chrome and go to chrome://dino/");
  Serial.println("2. Or disconnect internet and try to browse");
  Serial.println("3. Press spacebar once to start game");
  Serial.println("4. Then use blinks to jump!");
  Serial.println("");
  Serial.println("Starting EOG monitoring at 512 Hz...");
  Serial.println("Ready to play! ü¶ï");
}

void loop() {
    static unsigned long lastMicros = 0;
    static long timer = 0;
    
    digitalWrite(LED_PIN, LOW);  // Default LED state
    
    // Timing-based sampling for 512 Hz
    unsigned long currentMicros = micros();
    long interval = (long)(currentMicros - lastMicros);
    lastMicros = currentMicros;
    
    timer -= interval;
    const long period = 1000000L / SAMPLE_RATE;
    while (timer &lt; 0) {
        timer += period;
        int raw = analogRead(INPUT_PIN);
        float filtered = Notch(raw);
        float eog = EOGFilter(filtered);
        eogCircBuffer[writeIndex] = eog;
        writeIndex = (writeIndex + 1) % BUFFER_SIZE;
        if (samplesAvailable &lt; BUFFER_SIZE) {
            samplesAvailable++;
        }
    }
    
    // Process all available samples from circular buffer
    while (samplesAvailable &gt; 0) {
        float eog = eogCircBuffer[readIndex];
        readIndex = (readIndex + 1) % BUFFER_SIZE;
        samplesAvailable--;
        
        // Process the sample (envelope calculation)
        currentEOGEnvelope = updateEOGEnvelope(eog);
        
        // Add to segment buffer for statistics
        if(segmentIndex &lt; SAMPLES_PER_SEGMENT) {
            eogBuffer[segmentIndex] = currentEOGEnvelope;
            segmentIndex++;
        }
    }
    
    // Get current time for blink detection logic
    unsigned long nowMs = millis();
    
    // ===== SEGMENT STATISTICS PROCESSING =====
    if ((nowMs - lastSegmentTimeMs) &gt;= (1000UL * SEGMENT_SEC)) {
        if(segmentIndex &gt; 0) {
            // Compute min/max/avg for the completed segment
            eogMin = eogBuffer[0]; 
            eogMax = eogBuffer[0];  
            float eogSum = 0;
            
            for (uint16_t i = 0; i &lt; segmentIndex; i++) {
                float eogVal = eogBuffer[i];
                
                // EOG statistics
                if (eogVal &lt; eogMin) eogMin = eogVal;
                if (eogVal &gt; eogMax) eogMax = eogVal;
                eogSum += eogVal;
            }
            
            eogAvg = eogSum / segmentIndex;
            segmentStatsReady = true;
        }
        
        lastSegmentTimeMs = nowMs;
        segmentIndex = 0;
    }
    
    // ===== SINGLE BLINK DETECTION AND SPACE BAR CONTROL =====
    if (currentEOGEnvelope &gt; BlinkLowerThreshold && 
        currentEOGEnvelope &lt; BlinkUpperThreshold && 
        (nowMs - lastBlinkTime) &gt;= BLINK_DEBOUNCE_MS) {
        
        lastBlinkTime = nowMs;
        
        #ifdef DEBUG
        Serial.println("Blink detected!");
        #endif
        
        // Send space bar immediately for single blink
        sendSpaceBar();
    }
    
    // ===== PERIODIC STATUS UPDATES =====
    static unsigned long lastStatusUpdate = 0;
    if ((nowMs - lastStatusUpdate) &gt;= 30000) {  // Every 30 seconds
        unsigned long gameTimeSeconds = (nowMs - gameStartTime) / 1000;
        float blinksPerMinute = (totalBlinks * 60.0) / (gameTimeSeconds + 1);
        
        Serial.println("");
        Serial.println("=== Game Stats ===");
        Serial.print("Game Time: ");
        Serial.print(gameTimeSeconds);
        Serial.println(" seconds");
        Serial.print("Total Jumps: ");
        Serial.println(totalBlinks);
        Serial.print("Jump Rate: ");
        Serial.print(blinksPerMinute, 1);
        Serial.println(" per minute");
        Serial.print("Current EOG Level: ");
        Serial.println(currentEOGEnvelope);
        Serial.println("==================");
        Serial.println("");
        
        lastStatusUpdate = nowMs;
    }
    
    // ===== REAL-TIME EOG MONITORING (DEBUG) =====
    #ifdef DEBUG
    static unsigned long lastDebugPrint = 0;
    if ((nowMs - lastDebugPrint) &gt;= 1000) {  // Every 1 second
        if (segmentStatsReady) {
            Serial.print("EOG: (Avg: "); Serial.print(eogAvg);
            Serial.print(", Min: "); Serial.print(eogMin);
            Serial.print(", Max: "); Serial.print(eogMax); Serial.println(")");
        } else {
            Serial.println("EOG: "); Serial.print(currentEOGEnvelope);
        }
        lastDebugPrint = nowMs;
    }
    #endif
}
</code></pre>
    </div>
<!-- Warning Notice -->
<div style="background:linear-gradient(135deg,#7f1d1d,#991b1b); border-left:8px solid #ef4444; padding:20px 26px; border-radius:12px; margin:1.5em 0; color:#fee2e2; box-shadow:0 4px 18px rgba(0,0,0,0.3);">
  <strong style="font-size:17px; display:block; margin-bottom:10px;">‚ö†Ô∏è Important Notice</strong>
  <p>Keep laptop unplugged and remove the charger.</p>
</div>




    <h3>üìä Step 8: Testing the Connections</h3>
    <p>
        Open Serial Plotter ‚Üí Press SW1 ‚Üí Blink ‚Üí Observe clear spike signals.
    </p>

    <h3>ü¶ñ Step 10: Play the Game!</h3>
    <p>
        Control the <b>Chrome Dino Game</b> using only your <b>eye blinks</b> üéâ
    </p>

    <ul>
        <li>Open Google Chrome</li>
         <li>visit</li>
        <div class="code-box">
        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
         <pre><code>chrome://dino/</code></pre></div>
        <li>Press Space once to start</li>
        <li>Blink ‚Üí Dino Jumps!</li>
    </ul>

    <p style="font-weight:600; color:#ff8fa3;">
        Stronger blinks = higher accuracy üòéüëÅÔ∏èü¶ñ
    </p>
 <div class="soft-glow-img" style="max-width:600px; margin:35px auto;">
    <video controls style="width:100%; border-radius:16px; box-shadow:0 0 25px rgba(255,107,129,0.25);">
        <source src="dinogame.mp4" type="video/mp4">
       
    </video>

 </div>

    
</div>

<script>
function copyCode(btn) {
    // Find the <code> element right next to the button
    const codeElement = btn.parentElement.querySelector("code");

    // Get text inside code block
    const codeText = codeElement.innerText;

    navigator.clipboard.writeText(codeText)
        .then(() => {
            btn.innerText = "Copied!";
            setTimeout(() => { btn.innerText = "Copy"; }, 2000);
        })
        .catch(() => {
            alert("Copy failed. Please copy manually.");
        });
}
</script>




