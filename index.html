<!-- ===================== CYBERPUNK DARK MODE ‚Äî GLOBAL STYLES ===================== -->
<style>
    /* ==== GLOBAL PAGE ==== */
    body {
        font-family: "Poppins", "Inter", sans-serif;
        background: #0d0d0d; /* matte cyberpunk black */
        color: #e5e5e5;
        padding: 40px 20px;
        line-height: 1.7;
        text-align: center;
    }

    /* ==== NEON GRADIENT HEADINGS ==== */
    h2, h3 {
        background: linear-gradient(135deg, #00eaff, #b057ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    /* ==== CYBERPUNK CARD ==== */
    .section-card {
        max-width: 900px;
        margin: 40px auto;
        background: rgba(20, 20, 20, 0.9);
        padding: 35px;
        border-radius: 18px;
        box-shadow: 0 0 25px rgba(0, 238, 255, 0.2),
                    inset 0 0 20px rgba(176, 87, 255, 0.08);
        border: 1px solid rgba(0, 238, 255, 0.25);
        transition: 0.25s ease;
    }

    .section-card:hover {
        transform: translateY(-6px);
        box-shadow: 0 0 35px rgba(0, 238, 255, 0.35),
                    inset 0 0 25px rgba(176, 87, 255, 0.12);
    }

    .section-card img {
        width: 100%;
        border-radius: 16px;
        margin-top: 20px;
        box-shadow: 0 0 20px rgba(0, 238, 255, 0.25);
    }

    /* ==== CYBERPUNK LISTS ==== */
    ul {
        text-align: left;
        margin: 0 auto;
        padding-left: 20px;
        max-width: 700px;
    }

    /* ==== DIVIDER ==== */
    hr {
        margin: 40px auto;
        border: 0;
        height: 1px;
        width: 65%;
        background: linear-gradient(to right, transparent, #00eaff, transparent);
    }

    /* ========== NEON CODE BOX ========== */
    .code-box {
        background: #000000;
        border: 1px solid #00eaff;
        box-shadow: 0 0 20px rgba(0, 238, 255, 0.35),
                    inset 0 0 20px rgba(0, 238, 255, 0.08);
        border-radius: 16px;
        padding: 20px;
        margin: 40px auto;
        max-width: 850px;
        position: relative;
        text-align: left;
    }

    .code-box pre {
        color: #00ffea;
        font-family: monospace;
        white-space: pre-wrap;
    }

    /* ==== COPY BUTTON ==== */
    .copy-btn {
        position: absolute;
        top: 12px;
        right: 12px;
        background: #00eaff;
        color: #000;
        border: none;
        padding: 6px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 12px;
        transition: 0.3s ease;
    }

    .copy-btn:hover {
        background: #b057ff;
        color: #fff;
        box-shadow: 0 0 10px #b057ff;
    }

    /* ==== CYBERPUNK STEP TITLES ==== */
    .step-title {
        font-size: 26px;
        font-weight: 700;
        margin-top: 50px;
        background: linear-gradient(135deg,#ff3bbf,#00eaff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }

    .step-text {
        max-width: 850px;
        margin: 10px auto 25px auto;
        color: #cccccc;
    }
</style>


<!-- ===================== PROJECT 1 ‚Äî NEUROGRIP (DARK MODE) ===================== -->

<div class="section-card">
    <h2>Project 1: NeuroGrip ‚úã ‚Üí Controlling Servo Motor Using EMG</h2>

    <p>
        Build a simple EMG-based system using the <b>Muscle BioAmp Shield</b>  
        and <b>Arduino Uno</b> to control a servo claw ‚Äî just like prosthetic hands!
    </p>

    <h3>üî¨ What is Electromyography (EMG)?</h3>
    <p>
        EMG measures electrical signals produced by muscle contractions.  
        These signals help detect muscle activation and control assistive tech.
    </p>

    <img src="https://raw.githubusercontent.com/upsidedownlabs/Muscle-BioAmp-BisCute/main/software/EMGEnvelop/EMGEnvelop.png">

    <h3>üß© About Muscle BioAmp Shield</h3>
    <p>
        An Arduino-compatible EMG shield with plug-and-play sensors,  
        accelerometers, OLEDs, and servo support.
    </p>

    <img src="https://store.upsidedownlabs.tech/wp-content/uploads/2023/01/Muscle-BioAmp-Shield-v0.3.jpg">

    <h3>üß∞ Supplies Needed</h3>
    <ul>
        <li>Muscle BioAmp Shield Kit</li>
        <li>Arduino Uno + USB Cable</li>
        <li>Servo Claw</li>
        <li>NuPrep Gel</li>
        <li>Wet Wipes</li>
        <li>Electrode Gel</li>
        <li>Arduino IDE</li>
    </ul>

    <hr>

    <h3>üß™ Step 2: Stacking on Arduino Uno</h3>
    <p>Align shield pins properly before pressing it in.</p>

    <h3>üß¥ Step 3: Skin Preparation</h3>
    <p>Apply NuPrep gel ‚Üí rub gently ‚Üí wipe clean.</p>

    <h3>üîå Step 4: Connecting Electrode Cable</h3>
    <p>Connect the BioAmp cable exactly as shown ‚Äî do NOT put electrodes yet.</p>

    <h3>üìç Step 5: Electrode Placement</h3>

    <p><b>Option 1: Gel Electrodes</b></p>
    <ul>
        <li>Connect BioAmp Cable ‚Üí gel electrodes</li>
        <li>Place IN+/IN‚àí near ulnar nerve</li>
        <li>REF electrode on back of hand</li>
    </ul>

    <p><b>Option 2: EMG BioAmp Band</b></p>
    <ul>
        <li>IN+/IN‚àí positioned on ulnar nerve</li>
        <li>REF on opposite side</li>
        <li>Add small drops of electrode gel</li>
    </ul>

    <h3>ü¶æ Step 6: Connect Servo Claw</h3>
    <p>
        Plug the servo claw into the BioAmp Shield ports.  
        Servo moves automatically based on muscle activation.
    </p>

</div>


<h3 class="step-title">üß† Step 7 ‚Äî Upload the EMG ‚Üí Servo Control Code</h3>
<p class="step-text">
    Paste the following code into Arduino IDE and upload:
</p>

<div class="code-box">
    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>
#if defined(ESP32) 
  // For ESP32 Servo library
  #include <ESP32Servo.h>
#else
  // Arduino Servo library
  #include <Servo.h>
#endif

// Samples per second
#define SAMPLE_RATE 500

// Make sure to set the same baud rate on your Serial Monitor/Plotter
#define BAUD_RATE 115200

// Change if not using A0 analog pin
#define INPUT_PIN A0

// envelopeee buffer size
// High value -> smooth but less responsive
// Low value -> not smooth but responsive
#define BUFFER_SIZE 64

// Servo pin (Change as per your connection)
#define SERVO_PIN 2 // Pin2 for Muscle BioAmp Shield v0.3

// EMG Threshold value, different for each user
// Check by plotting EMG envelopee data on Serial plotter
#define EMG_THRESHOLD 47

// Servo open & close angles
#define SERVO_OPEN 10
#define SERVO_CLOSE 90

// EMG Envelope baseline value
// Minimum value without flexing hand
#define EMG_ENVELOPE_BASELINE 4

// EMG Envelope divider
// Minimum value increase required to turn on a single LED
#define EMG_ENVELOPE_DIVIDER 4


Servo servo;
// Servo toggle flag
bool flag = 0;
// Last gesture timestamp
unsigned long lastGestureTime = 0;
// Delay between two actions
unsigned long gestureDelay = 240;

int circular_buffer[BUFFER_SIZE];
int data_index, sum;

// Muscle BioAmp Shield v0.3 LED pin numbers in-order
int led_bar[] = {8, 9, 10, 11, 12, 13};
int total_leds = sizeof(led_bar) / sizeof(led_bar[0]);

void setup() {
  // Serial connection begin
  Serial.begin(BAUD_RATE);
  // Initialize all the led_bar
    for (int i = 0; i < total_leds; i++) {
      pinMode(led_bar[i], OUTPUT);
    }
   servo.attach(SERVO_PIN);
   servo.write(0);
}

void loop() {
  // Calculate elapsed time
  static unsigned long past = 0;
  unsigned long present = micros();
  unsigned long interval = present - past;
  past = present;

  // Run timer
  static long timer = 0;
  timer -= interval;

  // Sample and get envelope
  if(timer < 0) {
    timer += 1000000 / SAMPLE_RATE;
   
    // RAW EMG Values
    int sensor_value = analogRead(INPUT_PIN);
    
    // Filtered EMG
    int signal = EMGFilter(sensor_value);
    
    // EMG envelopee
    int envelope = getEnvelope(abs(signal));

    // Update LED bar graph
    for(int i = 0; i<=total_leds; i++){
      if(i>(envelope/EMG_ENVELOPE_DIVIDER - EMG_ENVELOPE_BASELINE)){
          digitalWrite(led_bar[i], LOW);
      } else {
          digitalWrite(led_bar[i], HIGH);
      }
    }
     
    if(envelope > EMG_THRESHOLD) {
      if((millis() - lastGestureTime) > gestureDelay){
      if(flag == 1){
        servo.write(SERVO_OPEN);
        flag = 0;
        lastGestureTime = millis();
      }
      else {
        servo.write(SERVO_CLOSE);
        flag = 1;
        lastGestureTime = millis();
      }
      }
    } 
    
    // EMG Raw signal
    Serial.print(signal);
    // Data seprator
    Serial.print(",");
    // EMG envelopeee
    Serial.println(envelope);

  }
}

// envelope detection algorithm
int getEnvelope(int abs_emg){
  sum -= circular_buffer[data_index];
  sum += abs_emg;
  circular_buffer[data_index] = abs_emg;
  data_index = (data_index + 1) % BUFFER_SIZE;
  return (sum/BUFFER_SIZE) * 2;
}
float EMGFilter(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - 0.05159732*z1 - 0.36347401*z2;
    output = 0.01856301*x + 0.03712602*z1 + 0.01856301*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -0.53945795*z1 - 0.39764934*z2;
    output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - 0.47319594*z1 - 0.70744137*z2;
    output = 1.00000000*x + 2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -1.00211112*z1 - 0.74520226*z2;
    output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

</code></pre>
</div>

<h3 class="step-title">ü¶æ Step 9 ‚Äî Control the Servo Claw</h3>
<p class="step-text">
    Flex your muscles ‚Üí envelope rises ‚Üí servo toggles.  
    Stronger flex = higher EMG = faster servo movement.
</p>
<!-- ===================== PROJECT 2 ‚Äî BLINK-A-SAUR (DARK MODE) ===================== -->

<div class="section-card">
    <h2>Project 2: Blink-a-saur ü¶ñ ‚Üí Control Dino Game Using EOG Signals</h2>

    <p>
        In this project, you will create a fun game controller that lets you 
        <b>play the Chrome Dino Game using your eye blinks</b>.  
        Using EOG (Electrooculography) signals from your eyes,  
        the system detects blinks and triggers a <b>keyboard SPACE press</b> ‚Äî letting the Dino jump!
    </p>

    <h3>üëÅÔ∏è What is Electrooculography (EOG)?</h3>
    <p>
        Electrooculography is a technique used to measure the electrical potential 
        produced by eye movement. The cornea is positively charged and the retina 
        is negatively charged, creating a standing potential known as the 
        <b>electrooculogram</b>. When you blink or move your eyes, this potential changes,  
        and we can detect it using biopotential amplifiers like the <b>BioAmp EXG Pill</b>.
    </p>

    <h3>üß∞ Supplies Needed</h3>

    <p><b>HARDWARE:</b></p>
    <ul>
        <li>DIY Neuroscience Kit Pro (includes EXG Pill, electrodes, gels, bands, Arduino Uno, etc.)</li>
        <li>BioAmp Cable (100 cm)</li>
        <li>Gel Electrodes</li>
        <li>NuPrep Skin Preparation Gel</li>
        <li>Wet wipes</li>
    </ul>

    <p><b>SOFTWARE:</b></p>
    <ul>
        <li>Arduino IDE</li>
        <li>Visual Studio Code</li>
        <li>Python</li>
    </ul>

    <h3>üî¨ About DIY Neuroscience Kit Pro</h3>
    <p>
        It works like a <b>portable neuroscience lab</b>, capable of recording 
        multiple biopotentials ‚Äî EEG, EMG, ECG, and EOG.  
        It's designed for students learning Human-Computer Interaction (HCI) 
        and Brain-Computer Interfaces (BCI).
    </p>

    <h3>üß™ Step 1: Stack Muscle BioAmp Shield on Arduino Uno</h3>
    <p>
        Carefully stack the <b>Muscle BioAmp Shield</b> on the Arduino Uno.  
        Make sure the pins align perfectly before pressing it down.
    </p>

    <img src="PUT-YOUR-IMAGE-LINK-HERE.jpg" alt="Muscle BioAmp Shield stacked on Arduino">
</div>

<!-- ---------------------- PROJECT 2 DETAILED STEPS ---------------------- -->

<h3 class="step-title">üß™ Step 1: Stack Muscle BioAmp Shield on Arduino Uno</h3>
<p class="step-text">
    Align all pins perfectly before pressing.
</p>

<img src="https://content.instructables.com/FUW/57PB/LY4F6XOC/FUW57PBLY4F6XOC.png?auto=webp&frame=1&crop=3:2&width=600&height=1024&fit=bounds"
     style="width:100%; border-radius:16px; margin-top:20px;"
     alt="Stacking example 1">

<img src="https://content.instructables.com/F7P/NORA/LY4F6XO1/F7PNORALY4F6XO1.png?auto=webp&frame=1&crop=3:2&width=600&height=1024&fit=bounds"
     style="width:100%; border-radius:16px; margin-top:20px;"
     alt="Stacking example 2">

<p class="step-text">
    Connect the <b>BioAmp EXG Pill</b> to the <b>A2 port</b> on the Muscle BioAmp Shield using the 3-pin STEMMA cable as shown above.
</p>

<h3 class="step-title">üîå Step 3: Connecting Electrode Cable</h3>
<p class="step-text">
    Connect the <b>BioAmp Cable</b> to the BioAmp EXG Pill exactly as shown in the reference video.
</p>

<h3 class="step-title">üß¥ Step 4: Skin Preparation</h3>
<p class="step-text">
    Apply <b>NuPrep Skin Preparation Gel</b> on the skin surface where electrodes will be placed  
    to remove dead skin cells and clean the area. After rubbing thoroughly, clean it with a wet wipe.
</p>

<p class="step-text">
    <b>About NuPrep Gel:</b><br>
    Nuprep improves conductivity by lowering skin impedance.  
    It removes the top dry skin layer and hydrates the surface, ensuring clear biopotential recordings.
</p>

<h3 class="step-title">üìç Step 5: Electrode Placements</h3>

<img src="https://content.instructables.com/FM2/O1W6/LNRH8FXV/FM2O1W6LNRH8FXV.jpg?auto=webp&frame=1&width=1024&height=1024&fit=bounds"
     style="width:100%; border-radius:16px; margin-top:20px;"
     alt="EOG electrode placement">

<ul class="center-ul">
    <li>Connect the BioAmp Cable to the gel electrodes</li>
    <li>Peel off the plastic backing from the electrodes</li>
    <li>Place:
        <br>‚Ä¢ <b>IN+</b> ‚Äî On the forehead  
        <br>‚Ä¢ <b>IN‚àí</b> ‚Äî Just below the eye  
        <br>‚Ä¢ <b>REF</b> ‚Äî On the bony part behind your earlobe
    </li>
</ul>

<h3 class="step-title">üíª Step 6: Download Arduino IDE</h3>
<p class="step-text">
    Download the Arduino IDE from:  
    <a href="https://www.arduino.cc/en/software" target="_blank">https://www.arduino.cc/en/software</a>
</p>
<p class="step-text">
    <b>Important:</b> Install <b>Arduino IDE 1.8.19 (Legacy Version)</b> for proper signal visualization.  
    After installation, connect the Arduino Uno to your laptop using the USB cable.
</p>

<h3 class="step-title">‚å®Ô∏è Step 7: Coding Time!</h3>
<p class="step-text">
    Download and unzip the firmware repository:  
    <a href="https://github.com/upsidedownlabs/Eye-BioAmp-Arduino-Firmware" target="_blank">
        Eye BioAmp Arduino Firmware (GitHub)
    </a>
</p>

<p class="step-text">
    Navigate to <code>6_EOGDinoGame</code> ‚Üí open <code>6_EOGDinoGame.ino</code> in Arduino IDE.  
    Go to <b>Tools ‚Üí Board ‚Üí Arduino UNO</b>, then select the correct <b>COM Port</b>.
</p>

<h3 class="step-title">üß† Step 7 Code: EOG Dino Game Controller</h3>

<div class="code-box">
    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>

#include <Arduino.h>
#include <Keyboard.h>  // HID keyboard library for Arduino R4
#include <math.h>

// #define DEBUG  // Uncomment this line to enable debugging

// ----------------- USER CONFIGURATION -----------------
#define SAMPLE_RATE       512          // samples per second
#define BAUD_RATE         115200
#define INPUT_PIN         A2
#define LED_PIN           LED_BUILTIN

// Envelope Configuration for EOG detection
#define ENVELOPE_WINDOW_MS 100  // Smoothing window in milliseconds
#define ENVELOPE_WINDOW_SIZE ((ENVELOPE_WINDOW_MS * SAMPLE_RATE) / 1000)

// Blink Detection Thresholds - adjust these based on your setup
const int BlinkLowerThreshold = 30; 
const int BlinkUpperThreshold = 50;

// Circular buffer for timing-based sampling
#define BUFFER_SIZE 64
float eogCircBuffer[BUFFER_SIZE];
int writeIndex = 0;
int readIndex = 0;
int samplesAvailable = 0;

// Single Blink Detection Configuration
const unsigned long BLINK_DEBOUNCE_MS = 300;   // minimum time between blinks to prevent double-triggering
unsigned long lastBlinkTime = 0;               // time of most recent blink
float currentEOGEnvelope = 0;

// HID Command Cooldown to prevent rapid-fire commands
const unsigned long HID_COOLDOWN_MS = 250;  // 250ms between space commands (allows ~4 jumps per second)
unsigned long lastHIDCommandTime = 0;

// EOG Envelope Processing Variables
float eogEnvelopeBuffer[ENVELOPE_WINDOW_SIZE] = {0};
int eogEnvelopeIndex = 0;
float eogEnvelopeSum = 0;

// Game Statistics
unsigned long totalBlinks = 0;
unsigned long gameStartTime = 0;

// EOG Statistics for debug display
#define SEGMENT_SEC 1
#define SAMPLES_PER_SEGMENT (SAMPLE_RATE * SEGMENT_SEC)
float eogBuffer[SAMPLES_PER_SEGMENT] = {0};
uint16_t segmentIndex = 0;
unsigned long lastSegmentTimeMs = 0;
float eogAvg = 0, eogMin = 0, eogMax = 0;
bool segmentStatsReady = false;

// --- Filter Functions ---

// Band-Stop Butterworth IIR digital filter, generated using filter_gen.py.
// Sampling rate: 512.0 Hz, frequency: [48.0, 52.0] Hz.
// Filter is order 2, implemented as second-order sections (biquads).
// Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
float Notch(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - -1.58696045*z1 - 0.96505858*z2;
    output = 0.96588529*x + -1.57986211*z1 + 0.96588529*z2;
    z2 = z1;
    z1 = x;
  }
  {
    static float z1, z2; // filter section state
    float x = output - -1.62761184*z1 - 0.96671306*z2;
    output = 1.00000000*x + -1.63566226*z1 + 1.00000000*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

// High-Pass Butterworth IIR digital filter, generated using filter_gen.py.
// Sampling rate: 512.0 Hz, frequency: 5.0 Hz.
// Filter is order 2, implemented as second-order sections (biquads).
// Reference: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
float EOGFilter(float input)
{
  float output = input;
  {
    static float z1, z2; // filter section state
    float x = output - -1.91327599*z1 - 0.91688335*z2;
    output = 0.95753983*x + -1.91507967*z1 + 0.95753983*z2;
    z2 = z1;
    z1 = x;
  }
  return output;
}

float updateEOGEnvelope(float sample) 
{
  float absSample = fabs(sample); 

  // Update circular buffer and running sum
  eogEnvelopeSum -= eogEnvelopeBuffer[eogEnvelopeIndex];
  eogEnvelopeSum += absSample;
  eogEnvelopeBuffer[eogEnvelopeIndex] = absSample;
  eogEnvelopeIndex = (eogEnvelopeIndex + 1) % ENVELOPE_WINDOW_SIZE;

  return eogEnvelopeSum / ENVELOPE_WINDOW_SIZE;  // Return moving average
}

// HID Keyboard Functions
void sendSpaceBar() {
  unsigned long nowMs = millis();
  if ((nowMs - lastHIDCommandTime) >= HID_COOLDOWN_MS) {
    Keyboard.press(' ');  // Press space bar
    delay(30);            // Hold key for 30ms (shorter for gaming responsiveness)
    Keyboard.release(' ');
    lastHIDCommandTime = nowMs;
    totalBlinks++;
    
    Serial.print("JUMP! Blink #");
    Serial.println(totalBlinks);
    
    // LED feedback - quick single flash
    digitalWrite(LED_PIN, HIGH);
    delay(50);
    digitalWrite(LED_PIN, LOW);
  }
}

void setup() {
  Serial.begin(BAUD_RATE);
  delay(100);
  
  pinMode(INPUT_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  
  // Initialize HID Keyboard
  Keyboard.begin();
  
  // LED startup sequence - game ready indicator
  for(int i = 0; i < 3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(200);
    digitalWrite(LED_PIN, LOW);
    delay(200);
  }
  
  gameStartTime = millis();
  lastSegmentTimeMs = millis();  // Initialize the segment timer
  
  Serial.println("=================================");
  Serial.println("Arduino R4 EOG Dino Game Controller");
  Serial.println("=================================");
  Serial.println("Single Blink = Space Bar (Jump)");
  Serial.println("Perfect for Chrome Dino Game!");
  Serial.println("");
  Serial.println("Instructions:");
  Serial.println("1. Open Chrome and go to chrome://dino/");
  Serial.println("2. Or disconnect internet and try to browse");
  Serial.println("3. Press spacebar once to start game");
  Serial.println("4. Then use blinks to jump!");
  Serial.println("");
  Serial.println("Starting EOG monitoring at 512 Hz...");
  Serial.println("Ready to play! ü¶ï");
}

void loop() {
    static unsigned long lastMicros = 0;
    static long timer = 0;
    
    digitalWrite(LED_PIN, LOW);  // Default LED state
    
    // Timing-based sampling for 512 Hz
    unsigned long currentMicros = micros();
    long interval = (long)(currentMicros - lastMicros);
    lastMicros = currentMicros;
    
    timer -= interval;
    const long period = 1000000L / SAMPLE_RATE;
    while (timer < 0) {
        timer += period;
        int raw = analogRead(INPUT_PIN);
        float filtered = Notch(raw);
        float eog = EOGFilter(filtered);
        eogCircBuffer[writeIndex] = eog;
        writeIndex = (writeIndex + 1) % BUFFER_SIZE;
        if (samplesAvailable < BUFFER_SIZE) {
            samplesAvailable++;
        }
    }
    
    // Process all available samples from circular buffer
    while (samplesAvailable > 0) {
        float eog = eogCircBuffer[readIndex];
        readIndex = (readIndex + 1) % BUFFER_SIZE;
        samplesAvailable--;
        
        // Process the sample (envelope calculation)
        currentEOGEnvelope = updateEOGEnvelope(eog);
        
        // Add to segment buffer for statistics
        if(segmentIndex < SAMPLES_PER_SEGMENT) {
            eogBuffer[segmentIndex] = currentEOGEnvelope;
            segmentIndex++;
        }
    }
    
    // Get current time for blink detection logic
    unsigned long nowMs = millis();
    
    // ===== SEGMENT STATISTICS PROCESSING =====
    if ((nowMs - lastSegmentTimeMs) >= (1000UL * SEGMENT_SEC)) {
        if(segmentIndex > 0) {
            // Compute min/max/avg for the completed segment
            eogMin = eogBuffer[0]; 
            eogMax = eogBuffer[0];  
            float eogSum = 0;
            
            for (uint16_t i = 0; i < segmentIndex; i++) {
                float eogVal = eogBuffer[i];
                
                // EOG statistics
                if (eogVal < eogMin) eogMin = eogVal;
                if (eogVal > eogMax) eogMax = eogVal;
                eogSum += eogVal;
            }
            
            eogAvg = eogSum / segmentIndex;
            segmentStatsReady = true;
        }
        
        lastSegmentTimeMs = nowMs;
        segmentIndex = 0;
    }
    
    // ===== SINGLE BLINK DETECTION AND SPACE BAR CONTROL =====
    if (currentEOGEnvelope > BlinkLowerThreshold && 
        currentEOGEnvelope < BlinkUpperThreshold && 
        (nowMs - lastBlinkTime) >= BLINK_DEBOUNCE_MS) {
        
        lastBlinkTime = nowMs;
        
        #ifdef DEBUG
        Serial.println("Blink detected!");
        #endif
        
        // Send space bar immediately for single blink
        sendSpaceBar();
    }
    
    // ===== PERIODIC STATUS UPDATES =====
    static unsigned long lastStatusUpdate = 0;
    if ((nowMs - lastStatusUpdate) >= 30000) {  // Every 30 seconds
        unsigned long gameTimeSeconds = (nowMs - gameStartTime) / 1000;
        float blinksPerMinute = (totalBlinks * 60.0) / (gameTimeSeconds + 1);
        
        Serial.println("");
        Serial.println("=== Game Stats ===");
        Serial.print("Game Time: ");
        Serial.print(gameTimeSeconds);
        Serial.println(" seconds");
        Serial.print("Total Jumps: ");
        Serial.println(totalBlinks);
        Serial.print("Jump Rate: ");
        Serial.print(blinksPerMinute, 1);
        Serial.println(" per minute");
        Serial.print("Current EOG Level: ");
        Serial.println(currentEOGEnvelope);
        Serial.println("==================");
        Serial.println("");
        
        lastStatusUpdate = nowMs;
    }
    
    // ===== REAL-TIME EOG MONITORING (DEBUG) =====
    #ifdef DEBUG
    static unsigned long lastDebugPrint = 0;
    if ((nowMs - lastDebugPrint) >= 1000) {  // Every 1 second
        if (segmentStatsReady) {
            Serial.print("EOG: (Avg: "); Serial.print(eogAvg);
            Serial.print(", Min: "); Serial.print(eogMin);
            Serial.print(", Max: "); Serial.print(eogMax); Serial.println(")");
        } else {
            Serial.println("EOG: "); Serial.print(currentEOGEnvelope);
        }
        lastDebugPrint = nowMs;
    }
    #endif
}
</code></pre>
</div>

<p class="step-text"><b>IMPORTANT:</b><br>
    Make sure your laptop is <b>not connected to a charger</b> and sit about <b>5m away</b>  
    from AC appliances for clean EOG signal acquisition.
</p>

<h3 class="step-title">üìä Step 8: Testing the Connections</h3>
<p class="step-text">
    In Arduino IDE, open <b>Tools ‚Üí Serial Plotter</b>.  
    Press the <b>SW1</b> button on the Muscle BioAmp Shield ‚Äî the green LED on the LED bar should glow.  
    Now blink your eyes and observe clear spikes in the Serial Plotter.
</p>

<h3 class="step-title">ü¶ñ Step 10: Play the Game!</h3>
<p class="step-text">
    You're now ready to control the <b>Chrome Dino Game</b> using only your <b>eye blinks</b> üéâ  
</p>

<ul class="center-ul">
    <li>Open Google Chrome</li>
    <li>Go to: <code>chrome://dino/</code></li>
    <li>Or go offline and try to browse any page to launch the game</li>
    <li>Press <b>Space</b> once to start the game</li>
    <li>Now blink your eyes to <b>make the Dino jump!</b></li>
</ul>

<p class="step-text" style="font-weight:600;">
    If your blink amplitude is strong enough, the controller will detect it  
    and trigger a <b>Space bar press</b> each time.  
    Try different blink intensities to find your sweet spot üòéüëÅÔ∏èü¶ñ
</p>
<!-- ===================== PROJECT 3 ‚Äî MINDSCOPE (DARK MODE) ===================== -->

<div class="section-card">
    <h2>Project 3: MindScope üîÆ ‚Üí Detecting Emotions Using EEG + GROK API</h2>

    <p>
        In this project, you will record EEG signals using the <b>BioAmp EXG Pill</b>  
        and an <b>ESP32 Dev Board</b>, extract brainwave bandpowers using FFT,  
        and classify emotional states like <b>Focused, Calm, Drowsy, Daydreaming, Hyper-aware</b>.  
        The output appears live in the <b>Serial Monitor</b>.
    </p>

    <h3>üß∞ Hardware Required</h3>
    <ul>
        <li>ESP32 Dev Board</li>
        <li>BioAmp EXG Pill</li>
        <li>BioAmp Cable v3</li>
        <li>3 √ó Gel Electrodes</li>
        <li>3 √ó Jumper Cables</li>
        <li>NuPrep Skin Preparation Gel</li>
        <li>Wet Wipe</li>
        <li>Brain BioAmp Band (optional)</li>
        <li>Electrode Gel (if using Brain BioAmp Band)</li>
    </ul>

    <h3>üíª Software Required</h3>
    <ul>
        <li>Arduino IDE</li>
    </ul>

    <h3>üîå Circuit Diagram</h3>
    <img src="https://content.instructables.com/F15/XHD3/M98IG675/F15XHD3M98IG675.png"
         alt="Circuit diagram showing EEG setup">

    <h3>üìç Electrode Placement</h3>
    <img src="https://content.instructables.com/FGF/1Q7B/M98IG66R/FGF1Q7BM98IG66R.png"
         alt="Electrode placement diagram">

    <p style="text-align:center; max-width:800px; margin:15px auto;">
        Apply <b>NuPrep Gel</b>, clean with a wet wipe, and place electrodes  
        according to the diagram. Ensure firm contact for the best EEG signal.
    </p>
</div>

<!-- ===================== STEP 1 ‚Äî UPLOAD CODE ===================== -->

<h3 class="step-title">üß™ Step 1: Upload the EEG Emotion Detection Program</h3>

<p class="step-text">
    Create a new sketch in Arduino IDE and paste the following code:
</p>

<div class="code-box">
    <button class="copy-btn" onclick="copyCode(this)">Copy</button>
<pre><code>
#include <arduinoFFT.h>

// ================= EEG + FFT Config =====================
#define SAMPLE_RATE 512
#define FFT_SIZE 256
#define BAUD_RATE 115200
#define INPUT_PIN A0
#define LED_PIN 2

// ================= Frequency Bands ======================
#define DELTA_LOW 0.5
#define DELTA_HIGH 4.0
#define THETA_LOW 4.0
#define THETA_HIGH 8.0
#define ALPHA_LOW 8.0
#define ALPHA_HIGH 13.0
#define BETA_LOW 13.0
#define BETA_HIGH 30.0
#define GAMMA_LOW 30.0
#define GAMMA_HIGH 45.0

// Less smoothing ‚Üí responds faster
#define SMOOTHING_FACTOR 0.35
const float EPSILON = 1e-6f;

// ================= Structs ==============================
typedef struct {
  float delta, theta, alpha, beta, gamma, total;
} BandpowerResults;

typedef struct {
  float delta = 0, theta = 0, alpha = 0, beta = 0, gamma = 0, total = 0;
} SmoothedBandpower;

SmoothedBandpower smoothedPowers;

// ================= FFT Buffers ==========================
double vReal[FFT_SIZE];
double vImag[FFT_SIZE];
ArduinoFFT<double> FFT(vReal, vImag, FFT_SIZE, SAMPLE_RATE);

// ================= Timing ================================
unsigned long lastEmotionTime = 0;
unsigned long sampling_period_us;

// ================= Functions =============================
void smoothBandpower(BandpowerResults *raw, SmoothedBandpower *s) {
  s->delta = SMOOTHING_FACTOR * raw->delta + (1 - SMOOTHING_FACTOR) * s->delta;
  s->theta = SMOOTHING_FACTOR * raw->theta + (1 - SMOOTHING_FACTOR) * s->theta;
  s->alpha = SMOOTHING_FACTOR * raw->alpha + (1 - SMOOTHING_FACTOR) * s->alpha;
  s->beta  = SMOOTHING_FACTOR * raw->beta  + (1 - SMOOTHING_FACTOR) * s->beta;
  s->gamma = SMOOTHING_FACTOR * raw->gamma + (1 - SMOOTHING_FACTOR) * s->gamma;
  s->total = SMOOTHING_FACTOR * raw->total + (1 - SMOOTHING_FACTOR) * s->total;
}

BandpowerResults calculateBandpower(double *powerSpectrum, double binWidth) {
  BandpowerResults results = {0};

  for (int i = 1; i < FFT_SIZE / 2; i++) {
    float freq = i * binWidth;
    float power = powerSpectrum[i];
    results.total += power;

    if (freq >= DELTA_LOW && freq < DELTA_HIGH) results.delta += power;
    else if (freq >= THETA_LOW && freq < THETA_HIGH) results.theta += power;
    else if (freq >= ALPHA_LOW && freq < ALPHA_HIGH) results.alpha += power;
    else if (freq >= BETA_LOW  && freq < BETA_HIGH)  results.beta  += power;
    else if (freq >= GAMMA_LOW && freq < GAMMA_HIGH) results.gamma += power;
  }
  return results;
}

// ================= Emotion Classification ==================
void printEmotion() {
  float d = (smoothedPowers.delta / (smoothedPowers.total + EPSILON)) * 100;
  float t = (smoothedPowers.theta / (smoothedPowers.total + EPSILON)) * 100;
  float a = (smoothedPowers.alpha / (smoothedPowers.total + EPSILON)) * 100;
  float b = (smoothedPowers.beta  / (smoothedPowers.total + EPSILON)) * 100;
  float g = (smoothedPowers.gamma / (smoothedPowers.total + EPSILON)) * 100;

  String emotion = "Neutral";

  // Very low signal ‚Üí no contact
  if (smoothedPowers.total < 0.001) {
    emotion = "No Signal";
  }
  else if (d > 60 && b < 10 && g < 10) {
    emotion = "Drowsy";
  }
  else if (t > a && t > b && t > 15) {
    emotion = "Daydreaming";
  }
  else if (b > 25 && b > a) {
    emotion = "Focused";
  }
  else if (a > 25 && a > b) {
    emotion = "Calm";
  }
  else if (g > 15) {
    emotion = "Hyper-aware";
  }

  Serial.print("Emotion: "); Serial.println(emotion);
  Serial.print("Delta: "); Serial.print(d, 1);
  Serial.print(" | Theta: "); Serial.print(t, 1);
  Serial.print(" | Alpha: "); Serial.print(a, 1);
  Serial.print(" | Beta: ");  Serial.print(b, 1);
  Serial.print(" | Gamma: "); Serial.println(g, 1);
}

// ================= Setup ==================
void setup() {
  Serial.begin(115200);
  pinMode(INPUT_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);

  sampling_period_us = round(1000000 * (1.0 / SAMPLE_RATE));

  Serial.println("EEG Emotion Detection (Improved) Started...");
}

// ================= Loop ==================
void loop() {
  unsigned long microseconds;

  // Sampling
  for (int i = 0; i < FFT_SIZE; i++) {
    microseconds = micros();
    vReal[i] = analogRead(INPUT_PIN);
    vImag[i] = 0;
    while (micros() - microseconds < sampling_period_us);
  }

  // FFT Processing
  FFT.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
  FFT.compute(FFT_FORWARD);
  FFT.complexToMagnitude();

  double binWidth = (1.0 * SAMPLE_RATE) / FFT_SIZE;

  BandpowerResults raw = calculateBandpower(vReal, binWidth);
  smoothBandpower(&raw, &smoothedPowers);

  // LED = "Focus indicator" (simple)
  double b_pct = (smoothedPowers.beta / (smoothedPowers.total + EPSILON)) * 100;
  digitalWrite(LED_PIN, (b_pct > 20.0 ? HIGH : LOW));

  // Print emotion every 5 sec
  if (millis() - lastEmotionTime > 5000) {
    printEmotion();
    lastEmotionTime = millis();
  }
}
</code></pre>
</div>

<!-- ===================== STEP 2 ‚Äî RESULTS ===================== -->

<h3 class="step-title">üìä Step 2: View Your Emotions Live</h3>

<p class="step-text">
    Open <b>Tools ‚Üí Serial Monitor</b> in Arduino IDE and set the baud rate to <b>115200</b>.
</p>

<p class="step-text">You will see outputs like:</p>

<div style="
    background:#050505;
    color:#00ff99;
    padding:18px;
    border-radius:14px;
    font-family:monospace;
    font-size:14px;
    max-width:700px;
    margin:20px auto;
    border:1px solid #00ffdd;
    box-shadow:0 0 16px rgba(0,255,230,0.5);
">
Emotion: Calm<br>
Delta: 12.3 | Theta: 18.4 | Alpha: 32.1 | Beta: 10.5 | Gamma: 2.1<br><br>
Emotion: Focused<br>
Delta: 10.2 | Theta: 8.4 | Alpha: 14.1 | Beta: 29.5 | Gamma: 3.0
</div>

<p class="step-text" style="font-weight:600;">
    Congratulations! Your device is now reading brainwaves  
    and detecting your <b>emotional state in real-time</b> üîÆüß†‚ú®
</p>
